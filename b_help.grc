<?xml version='1.0' encoding='utf-8'?>
<?grc format='1' created='3.7.13'?>
<flow_graph>
  <timestamp>Fri May  4 12:19:17 2018</timestamp>
  <block>
    <key>options</key>
    <param>
      <key>author</key>
      <value>Homero Ortega Boada</value>
    </param>
    <param>
      <key>window_size</key>
      <value></value>
    </param>
    <param>
      <key>category</key>
      <value>comdiguis</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>description</key>
      <value>Guardando aqui todos los bloques de programacion embebida</value>
    </param>
    <param>
      <key>_enabled</key>
      <value>True</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(0, 1)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>generate_options</key>
      <value>hb</value>
    </param>
    <param>
      <key>hier_block_src_path</key>
      <value>.:</value>
    </param>
    <param>
      <key>id</key>
      <value>b_help</value>
    </param>
    <param>
      <key>max_nouts</key>
      <value>0</value>
    </param>
    <param>
      <key>qt_qss_theme</key>
      <value></value>
    </param>
    <param>
      <key>realtime_scheduling</key>
      <value></value>
    </param>
    <param>
      <key>run_command</key>
      <value>{python} -u {filename}</value>
    </param>
    <param>
      <key>run_options</key>
      <value>prompt</value>
    </param>
    <param>
      <key>run</key>
      <value>True</value>
    </param>
    <param>
      <key>sizing_mode</key>
      <value>fixed</value>
    </param>
    <param>
      <key>thread_safe_setters</key>
      <value></value>
    </param>
    <param>
      <key>title</key>
      <value>b_help</value>
    </param>
    <param>
      <key>placement</key>
      <value>(0,0)</value>
    </param>
  </block>
  <block>
    <key>variable_qtgui_check_box</key>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>value</key>
      <value>True</value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>false</key>
      <value>False</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(384, 12)</value>
    </param>
    <param>
      <key>gui_hint</key>
      <value>0,0,1,1</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>run_stop</value>
    </param>
    <param>
      <key>label</key>
      <value>Inicial/Parar</value>
    </param>
    <param>
      <key>true</key>
      <value>True</value>
    </param>
    <param>
      <key>type</key>
      <value>real</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('e_Add_bb', 'blk', [], [('0', 'byte', 1), ('1', 'byte', 1)], [('0', 'byte', 1)], '', [])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class blk(gr.sync_block):  
#    """Suma dos senales tipo char"""
    def __init__(self,):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='e_Add_bb',   # will show up in GRC
            in_sig=[np.int8, np.int8],
            out_sig=[np.int8]
        )

    def work(self, input_items, output_items):
        output_items[0][:] = input_items[0]+input_items[1]
        return len(output_items[0])
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(672, 168)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>e_Add</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('e_M_PAM_decisor', 'blk', [('M', '4'), ('Vp', '4')], [('0', 'float', 1)], [('0', 'byte', 1)], '', ['M', 'Vp'])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class blk(gr.sync_block):  
#    """M-ary Decisor. Es un decisor para senales M_PAM. VP es el valor pico de la senal entrante"""
    def __init__(self,M=4, Vp=4):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='e_M_PAM_decisor',   # will show up in GRC
            in_sig=[np.float32],
            out_sig=[np.int8]
        )
	self.M=M
	self.Vp=Vp

    def work(self, input_items, output_items):
	mpam_con_ruido=input_items[0]*(self.M+1)/(2*self.Vp)
	mpam_sin_ruido=np.round(mpam_con_ruido)

        output_items[0][:] = mpam_sin_ruido.astype(np.int8)
        return len(output_items[0])
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(680, 260)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>180</value>
    </param>
    <param>
      <key>id</key>
      <value>e_M_decisor_0</value>
    </param>
    <param>
      <key>M</key>
      <value>M</value>
    </param>
    <param>
      <key>Vp</key>
      <value>3</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('e_Multiply_bb', 'blk', [], [('0', 'byte', 1), ('1', 'byte', 1)], [('0', 'byte', 1)], '', [])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class blk(gr.sync_block):  
#    """Multiplica dos senales tipo char"""
    def __init__(self,):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='e_Multiply_bb',   # will show up in GRC
            in_sig=[np.int8, np.int8],
            out_sig=[np.int8]
        )

    def work(self, input_items, output_items):
        output_items[0][:] = input_items[0]*input_items[1]
        return len(output_items[0])
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(792, 168)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>e_Multiply</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('e_VCO_fase_fc', 'blk', [], [('0', 'float', 1), ('1', 'float', 1)], [('0', 'complex', 1)], 'Done by Homero Ortega Boada. Es un VCO dos entradas: \n\tin0 para manipular la fase, in1 para manipular la \n\tmagnitud. En el fondo es el equivalente a un generador\n\tde una senal exponencial compleja. Sobre la configuracion:\n\tcada valor de la senal en in0 es interpretada como la fase\n\tdeseada en radianes. cada valor de in0, es la magnitud deseada', [])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>
import numpy as np
from gnuradio import gr


class blk(gr.sync_block):  
    """Done by Homero Ortega Boada. Es un VCO dos entradas: 
	in0 para manipular la fase, in1 para manipular la 
	magnitud. En el fondo es el equivalente a un generador
	de una senal exponencial compleja. Sobre la configuracion:
	cada valor de la senal en in0 es interpretada como la fase
	deseada en radianes. cada valor de in0, es la magnitud deseada"""

    def __init__(self): 
        gr.sync_block.__init__(self,
            name='e_VCO_fase_fc',
	    in_sig=[np.float32, np.float32],
            out_sig=[np.complex64]
        )
    def work(self, input_items, output_items):
	in0=input_items[0]
	in1=input_items[1]
	out0=output_items[0]
	out0[:] = in1*np.exp(1.j*in0)
	return len(out0)
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(536, 40)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>e_VCO_fase_fc_0</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('e_bipolar_to_unipolar_bb', 'blk', [], [('0', 'byte', 1)], [('0', 'byte', 1)], '', [])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class blk(gr.sync_block):  
#    """convierte de bipolar a unipolar una senal tipo char"""
    def __init__(self,):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='e_bipolar_to_unipolar_bb',   # will show up in GRC
            in_sig=[np.int8],
            out_sig=[np.int8]
        )

    def work(self, input_items, output_items):

        output_items[0][:] = (input_items[0]+1)/2
        return len(output_items[0])
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(376, 192)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>e_bipol_to_unip</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('e_bipolar_to_unipolar_M_bb', 'blk', [('M', '2')], [('0', 'byte', 1)], [('0', 'byte', 1)], '', ['M'])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class blk(gr.sync_block):  
#    """convierte de bipolar a unipolar una senal tipo char M-aria"""
    def __init__(self, M=2):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='e_bipolar_to_unipolar_M_bb',   # will show up in GRC
            in_sig=[np.int8],
            out_sig=[np.int8]
        )
	self.M=M
    def work(self, input_items, output_items):

        output_items[0][:] = (input_items[0]+(self.M-1))/2
        return len(output_items[0])
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(368, 284)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>e_bipol_to_unip_M</value>
    </param>
    <param>
      <key>M</key>
      <value>2</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('Complex to Phase', 'blk', [('M', '4')], [('0', 'complex', 1)], [('0', 'float', 1)], 'Autor: Homero Ortega. Permite obtener la fase de una senal compleja. A diferencia de otros bloques de gnuradio, este entrega valores positivos de fase entre 0 y 2pi. M es el numero de posibles fases discretas que trae la senal', ['M'])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class blk(gr.sync_block):  
    """Autor: Homero Ortega. Permite obtener la fase de una senal compleja. A diferencia de otros bloques de gnuradio, este entrega valores positivos de fase entre 0 y 2pi. M es el numero de posibles fases discretas que trae la senal"""
    def __init__(self,M=4):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='Complex to Phase',   # will show up in GRC
            in_sig=[np.complex64],
            out_sig=[np.float32]
        )
	self.M=M
	self.p2=2.*np.pi
	self.p_margen=self.p2/(M*2.)

    def work(self, input_items, output_items):
	fases=np.angle(input_items[0]) # tiene valores negativos
	fases=(fases+self.p_margen +self.p2)% self.p2-self.p_margen
        output_items[0][:] = fases
        return len(output_items[0])
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(824, 20)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>180</value>
    </param>
    <param>
      <key>id</key>
      <value>e_c_p</value>
    </param>
    <param>
      <key>M</key>
      <value>M</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('M_PAM to Phase', 'blk', [('M', '4')], [('0', 'byte', 1)], [('0', 'float', 1)], '', ['M'])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class blk(gr.sync_block):  
#    """Traduce M_PAM a valores de fase"""
    def __init__(self,M=4):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='M_PAM to Phase',   # will show up in GRC
            in_sig=[np.int8],
            out_sig=[np.float32]
        )
	self.M=M
	self.p2=2.*np.pi

    def work(self, input_items, output_items):
	#fases=input_items[0]*self.p2/self.M

        output_items[0][:] = input_items[0]*self.p2/self.M
        return len(output_items[0])
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(680, 84)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>e_mpam_ph</value>
    </param>
    <param>
      <key>M</key>
      <value>M</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('phase to M_PAM', 'blk', [('M', '4')], [('0', 'float', 1)], [('0', 'float', 1)], '', ['M'])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class blk(gr.sync_block):  
#    """Traduce fases a valores de M_PAM y aplica decisor mediante redondeo"""
    def __init__(self,M=4):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='phase to M_PAM',   # will show up in GRC
            in_sig=[np.float32],
            out_sig=[np.float32]
        )
	self.M=M
	self.p2=2.*np.pi

    def work(self, input_items, output_items):
	mpam_con_ruido=input_items[0]*self.M/self.p2
	mpam_sin_ruido=np.round(mpam_con_ruido)

        output_items[0][:] = mpam_sin_ruido
        return len(output_items[0])
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(680, 20)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>180</value>
    </param>
    <param>
      <key>id</key>
      <value>e_phase</value>
    </param>
    <param>
      <key>M</key>
      <value>M</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('phase to M_PAM', 'blk', [('M', '4')], [('0', 'float', 1)], [('0', 'byte', 1)], '', ['M'])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class blk(gr.sync_block):  
#    """Traduce fases a valores de M_PAM y aplica decisor mediante redondeo"""
    def __init__(self,M=4):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='phase to M_PAM',   # will show up in GRC
            in_sig=[np.float32],
            out_sig=[np.int8]
        )
	self.M=M
	self.p2=2.*np.pi

    def work(self, input_items, output_items):
	mpam_con_ruido=input_items[0]*self.M/self.p2
	mpam_sin_ruido=np.round(mpam_con_ruido)

        output_items[0][:] = mpam_sin_ruido.astype(np.int8)
        return len(output_items[0])
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(832, 76)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>180</value>
    </param>
    <param>
      <key>id</key>
      <value>e_phase_0</value>
    </param>
    <param>
      <key>M</key>
      <value>M</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('e_unipolar to bipolar_bb', 'blk', [], [('0', 'byte', 1)], [('0', 'byte', 1)], '', [])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class blk(gr.sync_block):  
#    """convierte de unipolar a bipolar una senal tipo char"""
    def __init__(self,):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='e_unipolar to bipolar_bb',   # will show up in GRC
            in_sig=[np.int8],
            out_sig=[np.int8]
        )

    def work(self, input_items, output_items):

        output_items[0][:] = input_items[0]*2-1
        return len(output_items[0])
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(376, 152)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>e_unip_to_bipol</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('e_unipolar to bipolar_M_bb', 'blk', [('M', '2')], [('0', 'byte', 1)], [('0', 'byte', 1)], '', ['M'])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class blk(gr.sync_block):  
#    """convierte de unipolar a bipolar una senal tipo char M-aria. El parametro M es para indicar si la senal es binaria (M=2), cuaternaria M=4, etc"""
    def __init__(self,M=2):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='e_unipolar to bipolar_M_bb',   # will show up in GRC
            in_sig=[np.int8],
            out_sig=[np.int8]
        )
	self.M=M

    def work(self, input_items, output_items):

        output_items[0][:] = input_items[0]*2-(self.M-1)
        return len(output_items[0])
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(368, 236)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>e_unip_to_bipol_M</value>
    </param>
    <param>
      <key>M</key>
      <value>2</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('positphase', 'blk', [], [('0', 'float', 1)], [('0', 'float', 1)], 'Coverts phase with some negative values to all positive values', [])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class blk(gr.sync_block):  
    """Coverts phase with some negative values to all positive values"""
    def __init__(self,):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='positphase',   # will show up in GRC
            in_sig=[np.float32],
            out_sig=[np.float32]
        )
	self.p2=2*np.pi

    def work(self, input_items, output_items):
        output_items[0][:] = (input_items[0] +self.p2) % self.p2
        return len(output_items[0])
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(288, 16)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>180</value>
    </param>
    <param>
      <key>id</key>
      <value>epy_block_0</value>
    </param>
  </block>
  <block>
    <key>epy_module</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>source_code</key>
      <value>import math
import numpy
#######################################################
##        Hecho por Homero Ortega Boada              ##
##        comdiguis@saber.uis.edu.co                 ##
##     Universidad Industrial de Santander           ##
#######################################################

#######################################################
##               Forma rectangular                   ##
#######################################################                       
def rect(Sps):
    return Sps*[1.,]

#######################################################
##               Forma de Nyquist                    ##
#######################################################                       
def nyq(Sps,ntaps):
    n=numpy.linspace(-int(ntaps/2), int(ntaps/2-1),ntaps)
    h=numpy.sinc(n/Sps)
#    return h/numpy.amax(h)
    return h
#######################################################
##               Forma Coseno Alzado                 ##
#######################################################                       
def rcos(Sps,ntaps,beta):
    if beta==0:
        h=nyq(Sps,ntaps)
    else:
        h=ntaps*[0,]
        for n in range(ntaps):
            k=n-ntaps/2. # esto es para que h[n] quede centrada en la mitad del vector
            if abs(k)==Sps/(2.*beta):
                h[n]=numpy.sinc(1./(2.*beta))*math.pi/4.
            else:
                h[n]=numpy.sinc(k/Sps)*math.cos(beta*k*math.pi/Sps)/(1.-(2.*beta*k/Sps)**2)                
    Amp=numpy.amax(h)
    return h/Amp
#######################################################
##            Forma Raiz de Coseno Alzado            ##
#######################################################                       

def rrcos(Sps,ntaps,beta):
    if beta==0:
        h=nyq(Sps,ntaps)
    else:
        h=ntaps*[0,]
        beta4=4.*beta
        for n in range(ntaps):
            k=n-ntaps/2. # esto es para que h[n] quede centrada en la mitad del vector
            if k==0:
                h[n]=1+beta*(4./math.pi-1.)
            elif abs(k)==Sps/beta4:
                ha=(1.+2./math.pi)*math.sin(math.pi/beta4)
                hb=(1.-2./math.pi)*math.cos(math.pi/beta4)
                h[n]=(ha+hb)*beta/math.sqrt(2.)
            else:
                ks=k/Sps
                kspi=math.pi*ks
                Num=math.sin(kspi*(1-beta))+beta4*ks*math.cos(kspi*(1+beta))
                Den=kspi*(1.-(beta4*ks)**2)
                h[n]=Num/Den                
    Amp=numpy.amax(h)
    return h/Amp
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>True</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(272, 92)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>wform</value>
    </param>
  </block>
  <connection>
    <source_block_id>e_c_p</source_block_id>
    <sink_block_id>e_phase</sink_block_id>
    <source_key>0</source_key>
    <sink_key>0</sink_key>
  </connection>
</flow_graph>
