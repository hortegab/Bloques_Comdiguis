<?xml version='1.0' encoding='utf-8'?>
<?grc format='1' created='3.7.13'?>
<flow_graph>
  <timestamp>Fri May  4 12:19:17 2018</timestamp>
  <block>
    <key>options</key>
    <param>
      <key>author</key>
      <value>Homero Ortega Boada</value>
    </param>
    <param>
      <key>window_size</key>
      <value></value>
    </param>
    <param>
      <key>category</key>
      <value>comdiguis</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>description</key>
      <value>Guardando aqui todos los bloques de programacion embebida</value>
    </param>
    <param>
      <key>_enabled</key>
      <value>True</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(0, 1)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>generate_options</key>
      <value>hb</value>
    </param>
    <param>
      <key>hier_block_src_path</key>
      <value>.:</value>
    </param>
    <param>
      <key>id</key>
      <value>b_help</value>
    </param>
    <param>
      <key>max_nouts</key>
      <value>0</value>
    </param>
    <param>
      <key>qt_qss_theme</key>
      <value></value>
    </param>
    <param>
      <key>realtime_scheduling</key>
      <value></value>
    </param>
    <param>
      <key>run_command</key>
      <value>{python} -u {filename}</value>
    </param>
    <param>
      <key>run_options</key>
      <value>prompt</value>
    </param>
    <param>
      <key>run</key>
      <value>True</value>
    </param>
    <param>
      <key>sizing_mode</key>
      <value>fixed</value>
    </param>
    <param>
      <key>thread_safe_setters</key>
      <value></value>
    </param>
    <param>
      <key>title</key>
      <value>b_help</value>
    </param>
    <param>
      <key>placement</key>
      <value>(0,0)</value>
    </param>
  </block>
  <block>
    <key>variable_qtgui_check_box</key>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>value</key>
      <value>True</value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>false</key>
      <value>False</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(384, 12)</value>
    </param>
    <param>
      <key>gui_hint</key>
      <value>0,0,1,1</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>run_stop</value>
    </param>
    <param>
      <key>label</key>
      <value>Inicial/Parar</value>
    </param>
    <param>
      <key>true</key>
      <value>True</value>
    </param>
    <param>
      <key>type</key>
      <value>real</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('VCO_hob', 'blk', [], [('0', 'float', 1), ('1', 'float', 1), ('2', 'float', 1)], [('0', 'float', 1)], 'genera una senoidad cuyos parametros pueden ser manipulados por las senales entrantes asi: la primera senal manipula la amplitud; la segunda la frecuencia; la tercera la fase', [])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import math
import numpy as np
from gnuradio import gr

class blk(gr.sync_block):
    """genera una senoidad cuyos parametros pueden ser manipulados por las senales entrantes asi: la primera senal manipula la amplitud; la segunda la frecuencia; la tercera la fase"""
    def __init__(self):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='VCO_hob',   # will show up in GRC
            in_sig=[np.float32, np.float32, np.float32],
            out_sig=[np.float32]
        )
        self.n_m=0 # guarda el ultimo valor de n

    def work(self, input_items, output_items):
        A=input_items[0]
        F=input_items[1]
        P=input_items[2]
        out=output_items[0]
        L=len(A)
        n=np.linspace(self.n_m, self.n_m+L-1,L)
        self.n_m += L
        out[:]=A*np.cos(2*math.pi*F*n+P)
        return len(out)
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(376, 336)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>VCO_hob</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('e_Add_bb', 'blk', [], [('0', 'byte', 1), ('1', 'byte', 1)], [('0', 'byte', 1)], '', [])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class blk(gr.sync_block):  
#    """Suma dos senales tipo char"""
    def __init__(self,):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='e_Add_bb',   # will show up in GRC
            in_sig=[np.int8, np.int8],
            out_sig=[np.int8]
        )

    def work(self, input_items, output_items):
        output_items[0][:] = input_items[0]+input_items[1]
        return len(output_items[0])
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(672, 168)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>e_Add</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('e_M_PAM_decisor', 'blk', [('M', '4'), ('Vp', '4')], [('0', 'float', 1)], [('0', 'byte', 1)], '', ['M', 'Vp'])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class blk(gr.sync_block):  
#    """M-ary Decisor. Es un decisor para senales M_PAM. VP es el valor pico de la senal entrante"""
    def __init__(self,M=4, Vp=4):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='e_M_PAM_decisor',   # will show up in GRC
            in_sig=[np.float32],
            out_sig=[np.int8]
        )
	self.M=M
	self.Vp=Vp

    def work(self, input_items, output_items):
	mpam_con_ruido=input_items[0]*(self.M+1)/(2*self.Vp)
	mpam_sin_ruido=np.round(mpam_con_ruido)

        output_items[0][:] = mpam_sin_ruido.astype(np.int8)
        return len(output_items[0])
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(680, 260)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>180</value>
    </param>
    <param>
      <key>id</key>
      <value>e_M_decisor_0</value>
    </param>
    <param>
      <key>M</key>
      <value>M</value>
    </param>
    <param>
      <key>Vp</key>
      <value>3</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('e_Multiply_bb', 'blk', [], [('0', 'byte', 1), ('1', 'byte', 1)], [('0', 'byte', 1)], '', [])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class blk(gr.sync_block):  
#    """Multiplica dos senales tipo char"""
    def __init__(self,):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='e_Multiply_bb',   # will show up in GRC
            in_sig=[np.int8, np.int8],
            out_sig=[np.int8]
        )

    def work(self, input_items, output_items):
        output_items[0][:] = input_items[0]*input_items[1]
        return len(output_items[0])
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(792, 168)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>e_Multiply</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('e_VCO_fase_fc', 'blk', [], [('0', 'float', 1), ('1', 'float', 1)], [('0', 'complex', 1)], 'Done by Homero Ortega Boada. Es un VCO dos entradas: \n\tin0 para manipular la fase, in1 para manipular la \n\tmagnitud. En el fondo es el equivalente a un generador\n\tde una senal exponencial compleja. Sobre la configuracion:\n\tcada valor de la senal en in0 es interpretada como la fase\n\tdeseada en radianes. cada valor de in0, es la magnitud deseada', [])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>
import numpy as np
from gnuradio import gr


class blk(gr.sync_block):  
    """Done by Homero Ortega Boada. Es un VCO dos entradas: 
	in0 para manipular la fase, in1 para manipular la 
	magnitud. En el fondo es el equivalente a un generador
	de una senal exponencial compleja. Sobre la configuracion:
	cada valor de la senal en in0 es interpretada como la fase
	deseada en radianes. cada valor de in0, es la magnitud deseada"""

    def __init__(self): 
        gr.sync_block.__init__(self,
            name='e_VCO_fase_fc',
	    in_sig=[np.float32, np.float32],
            out_sig=[np.complex64]
        )
    def work(self, input_items, output_items):
	in0=input_items[0]
	in1=input_items[1]
	out0=output_items[0]
	out0[:] = in1*np.exp(1.j*in0)
	return len(out0)
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(536, 40)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>e_VCO_fase_fc_0</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('e_VCO_fase_fc', 'blk', [], [('0', 'float', 1), ('1', 'float', 1)], [('0', 'complex', 1)], 'Done by Homero Ortega Boada. Es un VCO dos entradas: \n\tin0 para manipular la fase, in1 para manipular la \n\tmagnitud. En el fondo es el equivalente a un generador\n\tde una senal exponencial compleja. Sobre la configuracion:\n\tcada valor de la senal en in0 es interpretada como la fase\n\tdeseada en radianes. cada valor de in0, es la magnitud deseada', [])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>
import numpy as np
from gnuradio import gr


class blk(gr.sync_block):  
    """Done by Homero Ortega Boada. Es un VCO dos entradas: 
	in0 para manipular la fase, in1 para manipular la 
	magnitud. En el fondo es el equivalente a un generador
	de una senal exponencial compleja. Sobre la configuracion:
	cada valor de la senal en in0 es interpretada como la fase
	deseada en radianes. cada valor de in0, es la magnitud deseada"""

    def __init__(self): 
        gr.sync_block.__init__(self,
            name='e_VCO_fase_fc',
	    in_sig=[np.float32, np.float32],
            out_sig=[np.complex64]
        )
    def work(self, input_items, output_items):
	in0=input_items[0]
	in1=input_items[1]
	out0=output_items[0]
	out0[:] = in1*np.exp(1.j*in0)
	return len(out0)
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(592, 448)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>e_VCO_fase_fc_0_0</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('e_bipolar_to_unipolar_bb', 'blk', [], [('0', 'byte', 1)], [('0', 'byte', 1)], '', [])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class blk(gr.sync_block):  
#    """convierte de bipolar a unipolar una senal tipo char"""
    def __init__(self,):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='e_bipolar_to_unipolar_bb',   # will show up in GRC
            in_sig=[np.int8],
            out_sig=[np.int8]
        )

    def work(self, input_items, output_items):

        output_items[0][:] = (input_items[0]+1)/2
        return len(output_items[0])
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(376, 192)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>e_bipol_to_unip</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('e_bipolar_to_unipolar_M_bb', 'blk', [('M', '2')], [('0', 'byte', 1)], [('0', 'byte', 1)], '', ['M'])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class blk(gr.sync_block):  
#    """convierte de bipolar a unipolar una senal tipo char M-aria"""
    def __init__(self, M=2):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='e_bipolar_to_unipolar_M_bb',   # will show up in GRC
            in_sig=[np.int8],
            out_sig=[np.int8]
        )
	self.M=M
    def work(self, input_items, output_items):

        output_items[0][:] = (input_items[0]+(self.M-1))/2
        return len(output_items[0])
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(368, 284)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>e_bipol_to_unip_M</value>
    </param>
    <param>
      <key>M</key>
      <value>2</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('Complex to Phase', 'blk', [('M', '4')], [('0', 'complex', 1)], [('0', 'float', 1)], 'Autor: Homero Ortega. Permite obtener la fase de una senal compleja. A diferencia de otros bloques de gnuradio, este entrega valores positivos de fase entre 0 y 2pi. M es el numero de posibles fases discretas que trae la senal', ['M'])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class blk(gr.sync_block):  
    """Autor: Homero Ortega. Permite obtener la fase de una senal compleja. A diferencia de otros bloques de gnuradio, este entrega valores positivos de fase entre 0 y 2pi. M es el numero de posibles fases discretas que trae la senal"""
    def __init__(self,M=4):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='Complex to Phase',   # will show up in GRC
            in_sig=[np.complex64],
            out_sig=[np.float32]
        )
	self.M=M
	self.p2=2.*np.pi
	self.p_margen=self.p2/(M*2.)

    def work(self, input_items, output_items):
	fases=np.angle(input_items[0]) # tiene valores negativos
	fases=(fases+self.p_margen +self.p2)% self.p2-self.p_margen
        output_items[0][:] = fases
        return len(output_items[0])
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(824, 20)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>180</value>
    </param>
    <param>
      <key>id</key>
      <value>e_c_p</value>
    </param>
    <param>
      <key>M</key>
      <value>M</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('M_PAM to Phase', 'blk', [('M', '4')], [('0', 'byte', 1)], [('0', 'float', 1)], '', ['M'])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class blk(gr.sync_block):  
#    """Traduce M_PAM a valores de fase"""
    def __init__(self,M=4):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='M_PAM to Phase',   # will show up in GRC
            in_sig=[np.int8],
            out_sig=[np.float32]
        )
	self.M=M
	self.p2=2.*np.pi

    def work(self, input_items, output_items):
	#fases=input_items[0]*self.p2/self.M

        output_items[0][:] = input_items[0]*self.p2/self.M
        return len(output_items[0])
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(680, 84)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>e_mpam_ph</value>
    </param>
    <param>
      <key>M</key>
      <value>M</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('phase to M_PAM', 'blk', [('M', '4')], [('0', 'float', 1)], [('0', 'float', 1)], '', ['M'])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class blk(gr.sync_block):  
#    """Traduce fases a valores de M_PAM y aplica decisor mediante redondeo"""
    def __init__(self,M=4):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='phase to M_PAM',   # will show up in GRC
            in_sig=[np.float32],
            out_sig=[np.float32]
        )
	self.M=M
	self.p2=2.*np.pi

    def work(self, input_items, output_items):
	mpam_con_ruido=input_items[0]*self.M/self.p2
	mpam_sin_ruido=np.round(mpam_con_ruido)

        output_items[0][:] = mpam_sin_ruido
        return len(output_items[0])
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(680, 20)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>180</value>
    </param>
    <param>
      <key>id</key>
      <value>e_phase</value>
    </param>
    <param>
      <key>M</key>
      <value>M</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('phase to M_PAM', 'blk', [('M', '4')], [('0', 'float', 1)], [('0', 'byte', 1)], '', ['M'])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class blk(gr.sync_block):  
#    """Traduce fases a valores de M_PAM y aplica decisor mediante redondeo"""
    def __init__(self,M=4):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='phase to M_PAM',   # will show up in GRC
            in_sig=[np.float32],
            out_sig=[np.int8]
        )
	self.M=M
	self.p2=2.*np.pi

    def work(self, input_items, output_items):
	mpam_con_ruido=input_items[0]*self.M/self.p2
	mpam_sin_ruido=np.round(mpam_con_ruido)

        output_items[0][:] = mpam_sin_ruido.astype(np.int8)
        return len(output_items[0])
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(832, 76)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>180</value>
    </param>
    <param>
      <key>id</key>
      <value>e_phase_0</value>
    </param>
    <param>
      <key>M</key>
      <value>M</value>
    </param>
  </block>
  <block>
    <key>epy_module</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>source_code</key>
      <value>################################################################################
##           Funciones sigulares en Tratamiento de senales y sistemas         ##
################################################################################
# Lo siguiente aplica para todas las funciones aqui incluidas:
# cada funcion busca generar un tipo de forma de pulso rodeada de ceros
# los resultados se entregan en forma de un vector x
# Estos son los parametros usados:
# ntaps: es el tamano del vector y coincide con la duracion de la senal generada
# nzero: es el numero de ceros que rodean el pulso generado. Si nzero=0 no 
# habran ceros.
import numpy as np

def pulse_rect(ntaps,nzeros):
# Descripcion: esta funcion permite generar un pulso rectangular discreto
	n_val=ntaps-nzeros             # el numero de valores no iguales a cero
	x=np.zeros(ntaps)       # crea un vector de tamano ntaps lleno de ceros
	ntaps_m= int(ntaps/2)                # el punto medio del vector
	ntaps_i= ntaps_m-int(n_val/2)        # el punto de inicio para los unos
	x[ntaps_i:ntaps_i+n_val:1]=np.ones(n_val) # llenado de los unos
	return x

def pulse_ramp(ntaps,nzeros):
# Descripcion: esta funcion permite generar un pulso en forma de rampa discreto
	n_val=ntaps-nzeros            
	x=np.zeros(ntaps)             
	ntaps_m= int(ntaps/2)         
	ntaps_i= ntaps_m-int(n_val/2) 
	x[ntaps_i:ntaps_i+n_ones:1]=np.linspace(0,n_val-1,n_val) 
	return x

def pulse_delta(ntaps):
# Descripcion: esta funcion permite generar la funcion impulso o funcion
# delta de Dirac discreta
	x=np.zeros(ntaps)                      
	ntaps_m= int(ntaps/2)                  
	x[ntaps_m]=1                           
	return x

def pulse_doublet(ntaps):
# Descripcion: esta funcion permite generar una funcion doblete unitario discreta
	x=np.zeros(ntaps)                      
	ntaps_m= int(ntaps/2)                  
	x[ntaps_m]=1                           
	x[ntaps_m+1]=-1                        
	return x

def pulse_step(ntaps, nzeros):
# Descripcion: esta funcion permite generar una funcion escalon de Heaviside
	n_val=ntaps-nzeros                     
	x=np.zeros(ntaps)                      
	x[nzeros:ntaps:1]=np.ones(n_val) 
	return x

def pulse_exp(ntaps,nzeros, C, a):
# Descripcion: Para generar una funcion exponencial de la forma Ca^n, 
# donde n es tiempo discreto
	n_val=ntaps-nzeros                        
	x=np.zeros(ntaps)                         
	ntaps_i = nzeros                    
	n=np.linspace(0,n_val-1,n_val)      
	x[ntaps_i:ntaps:1]=C*np.power(a,n) 
	return x

</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>True</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(16, 180)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>e_signal</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('e_unipolar to bipolar_bb', 'blk', [], [('0', 'byte', 1)], [('0', 'byte', 1)], '', [])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class blk(gr.sync_block):  
#    """convierte de unipolar a bipolar una senal tipo char"""
    def __init__(self,):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='e_unipolar to bipolar_bb',   # will show up in GRC
            in_sig=[np.int8],
            out_sig=[np.int8]
        )

    def work(self, input_items, output_items):

        output_items[0][:] = input_items[0]*2-1
        return len(output_items[0])
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(376, 152)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>e_unip_to_bipol</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('e_unipolar to bipolar_M_bb', 'blk', [('M', '2')], [('0', 'byte', 1)], [('0', 'byte', 1)], '', ['M'])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class blk(gr.sync_block):  
#    """convierte de unipolar a bipolar una senal tipo char M-aria. El parametro M es para indicar si la senal es binaria (M=2), cuaternaria M=4, etc"""
    def __init__(self,M=2):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='e_unipolar to bipolar_M_bb',   # will show up in GRC
            in_sig=[np.int8],
            out_sig=[np.int8]
        )
	self.M=M

    def work(self, input_items, output_items):

        output_items[0][:] = input_items[0]*2-(self.M-1)
        return len(output_items[0])
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(368, 236)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>e_unip_to_bipol_M</value>
    </param>
    <param>
      <key>M</key>
      <value>2</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('positphase', 'blk', [], [('0', 'float', 1)], [('0', 'float', 1)], 'Coverts phase with some negative values to all positive values', [])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class blk(gr.sync_block):  
    """Coverts phase with some negative values to all positive values"""
    def __init__(self,):  # only default arguments here
        gr.sync_block.__init__(
            self,
            name='positphase',   # will show up in GRC
            in_sig=[np.float32],
            out_sig=[np.float32]
        )
	self.p2=2*np.pi

    def work(self, input_items, output_items):
        output_items[0][:] = (input_items[0] +self.p2) % self.p2
        return len(output_items[0])
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(288, 16)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>180</value>
    </param>
    <param>
      <key>id</key>
      <value>epy_block_0</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('e_mean_meter_ff', 'mean_meter', [], [('0', 'float', 1)], [('0', 'float', 1)], 'Descripcion del bloque ', [])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class mean_meter(gr.sync_block):
    """Descripcion del bloque """
    def __init__(self):
        gr.sync_block.__init__(self,
            name="e_mean_meter_ff",
            in_sig=[np.float32],
            out_sig=[np.float32])

        # variables externas
	self.contador = 0
	self.acum=0
    def work(self, input_items, output_items):
        # traduccion a algo que podemos manejar mejor
        in0 = input_items[0]
        out0 = output_items[0]
        # Logica principal
	self.contador += len(in0)
	self.acum += np.sum(in0)
	out0[:] = self.acum/self.contador
        return len(output_items[0])

</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(192, 176)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>epy_block_0_0</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('e_diezmad_ff', 'decimator', [('paso', '2')], [('0', 'float', 1)], [('0', 'float', 1)], 'Elimins paso-1 muestras, de manera que solo quedan vigentes las muestras separadas en paso muestras', ['paso'])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>import numpy as np
from gnuradio import gr

class decimator(gr.decim_block):
    """Elimins paso-1 muestras, de manera que solo quedan vigentes las muestras separadas en paso muestras"""
    def __init__(self, paso=2):
        gr.decim_block.__init__(self,
            name="e_diezmad_ff",
            in_sig=[np.float32],
            out_sig=[np.float32], decim=paso)

        # variables externas
	self.paso = paso
	
    def work(self, input_items, output_items):
        # traduccion a algo que podemos manejar mejor
        in0 = input_items[0]
        out0 = output_items[0]
        # Logica principal
	out0[:] = in0[::self.paso]
        return len(output_items[0])

</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(792, 404)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>epy_block_0_0_0</value>
    </param>
    <param>
      <key>paso</key>
      <value>Kd</value>
    </param>
  </block>
  <block>
    <key>epy_block</key>
    <param>
      <key>Ac</key>
      <value>1.0</value>
    </param>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>_io_cache</key>
      <value>('e_VCO_frec_fc', 'blk', [('samp_rate', '200000.0'), ('Ac', '1.0')], [('0', 'float', 1)], [('0', 'complex', 1)], 'Done by Homero Ortega Boada', ['Ac', 'samp_rate'])</value>
    </param>
    <param>
      <key>_source_code</key>
      <value>"""
Embedded Python Blocks:

Each time this file is saved, GRC will instantiate the first class it finds
to get ports and parameters of your block. The arguments to __init__  will
be the parameters. All of them are required to have default values!
"""

import numpy as np
from gnuradio import gr


class blk(gr.sync_block):  
    """Done by Homero Ortega Boada"""

    def __init__(self, samp_rate=200000., Ac=1.):  # only default arguments here
        """arguments to this function show up as parameters in GRC"""
        gr.sync_block.__init__(
            self,
            name='e_VCO_frec_fc',   # will show up in GRC
            in_sig=[np.float32],
            out_sig=[np.complex64]
        )
        self.samp_rate = float(samp_rate)
        self.Ac = Ac
	self.last_t=0.

    def work(self, input_items, output_items):
	in0=input_items[0]
	out0=output_items[0]
        L=len(in0)
	t=np.arange(L)/self.samp_rate+self.last_t
	theta=2.*np.pi*in0*t
	out0[:] = self.Ac*np.exp(1.j*theta)
	self.last_t += L/self.samp_rate
	return len(out0)
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>0</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(368, 460)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>epy_block_0_1</value>
    </param>
    <param>
      <key>samp_rate</key>
      <value>samp_rate</value>
    </param>
  </block>
  <block>
    <key>epy_module</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>source_code</key>
      <value>import math
import numpy as np
# Cada funcion siguinete es una forma de pulso para una senal digital
# Los parametros comunmente usados son:
# Sps (Samples per simbol): Duracion de un simbolo en tiempo discreto
# ntaps: es el numero de muestras a generar por simbolo. Esto debido a que,
# en la practica, un simbolo puede invadir a otros simbolos (ISI), asi que
# las muestras de un simbolo se pueden expandir mas alla de Sps

# Bipolar non return to zero level signal
def B_NRZ_L(Sps):
    return Sps*[1.,]
##  Forma sinc 
def sinc(Sps,ntaps):
    n=np.linspace(-int(ntaps/2), int(ntaps/2-1),ntaps)
    h=np.sinc(n/Sps)
    return h
# forma diente se sierra
def saw(Sps):
    return np.linspace(0,Sps-1,Sps)	
# Bipolar non return to zero signal
def RZ(Sps):
    h=Sps*[1.,]
    Sps_m=int(Sps/2)
    h[Sps_m+1:Sps:1]=np.zeros(Sps-Sps_m)
    return h

</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>True</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(16, 220)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>formas</value>
    </param>
  </block>
  <block>
    <key>epy_module</key>
    <param>
      <key>alias</key>
      <value></value>
    </param>
    <param>
      <key>source_code</key>
      <value>import math
import numpy
#######################################################
##        Hecho por Homero Ortega Boada              ##
##        comdiguis@saber.uis.edu.co                 ##
##     Universidad Industrial de Santander           ##
#######################################################

#######################################################
##               Forma rectangular                   ##
#######################################################                       
def rect(Sps):
    return Sps*[1.,]

#######################################################
##               Forma de Nyquist                    ##
#######################################################                       
def nyq(Sps,ntaps):
    n=numpy.linspace(-int(ntaps/2), int(ntaps/2-1),ntaps)
    h=numpy.sinc(n/Sps)
#    return h/numpy.amax(h)
    return h
#######################################################
##               Forma Coseno Alzado                 ##
#######################################################                       
def rcos(Sps,ntaps,beta):
    if beta==0:
        h=nyq(Sps,ntaps)
    else:
        h=ntaps*[0,]
        for n in range(ntaps):
            k=n-ntaps/2. # esto es para que h[n] quede centrada en la mitad del vector
            if abs(k)==Sps/(2.*beta):
                h[n]=numpy.sinc(1./(2.*beta))*math.pi/4.
            else:
                h[n]=numpy.sinc(k/Sps)*math.cos(beta*k*math.pi/Sps)/(1.-(2.*beta*k/Sps)**2)                
    Amp=numpy.amax(h)
    return h/Amp
#######################################################
##            Forma Raiz de Coseno Alzado            ##
#######################################################                       

def rrcos(Sps,ntaps,beta):
    if beta==0:
        h=nyq(Sps,ntaps)
    else:
        h=ntaps*[0,]
        beta4=4.*beta
        for n in range(ntaps):
            k=n-ntaps/2. # esto es para que h[n] quede centrada en la mitad del vector
            if k==0:
                h[n]=1+beta*(4./math.pi-1.)
            elif abs(k)==Sps/beta4:
                ha=(1.+2./math.pi)*math.sin(math.pi/beta4)
                hb=(1.-2./math.pi)*math.cos(math.pi/beta4)
                h[n]=(ha+hb)*beta/math.sqrt(2.)
            else:
                ks=k/Sps
                kspi=math.pi*ks
                Num=math.sin(kspi*(1-beta))+beta4*ks*math.cos(kspi*(1+beta))
                Den=kspi*(1.-(beta4*ks)**2)
                h[n]=Num/Den                
    Amp=numpy.amax(h)
    return h/Amp
</value>
    </param>
    <param>
      <key>comment</key>
      <value></value>
    </param>
    <param>
      <key>_enabled</key>
      <value>True</value>
    </param>
    <param>
      <key>_coordinate</key>
      <value>(16, 148)</value>
    </param>
    <param>
      <key>_rotation</key>
      <value>0</value>
    </param>
    <param>
      <key>id</key>
      <value>wform</value>
    </param>
  </block>
  <connection>
    <source_block_id>e_c_p</source_block_id>
    <sink_block_id>e_phase</sink_block_id>
    <source_key>0</source_key>
    <sink_key>0</sink_key>
  </connection>
</flow_graph>
